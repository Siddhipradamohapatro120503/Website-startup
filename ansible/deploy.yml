---
- name: Deploy Application
  hosts: production
  become: yes
  vars:
    app_dir: /opt/startup-app
    docker_compose_file: "{{ app_dir }}/docker-compose.prod.yml"
    env_file: "{{ app_dir }}/.env"
    domain_name: "{{ domain }}"
    email: "{{ certbot_email }}"
    razorpay_key_id: "{{ vault_razorpay_key_id }}"
    razorpay_key_secret: "{{ vault_razorpay_key_secret }}"
    mongo_user: "{{ mongo_user }}"
    mongo_password: "{{ mongo_password }}"
    mongo_port: 27017
    mongodb_uri: "mongodb://{{ mongo_user }}:{{ mongo_password }}@localhost:{{ mongo_port }}/startup_db"

  tasks:
    - name: Install required system packages
      apt:
        name: "{{ item }}"
        state: present
        update_cache: yes
      loop:
        - apt-transport-https
        - ca-certificates
        - curl
        - software-properties-common
        - python3-pip
        - virtualenv
        - python3-setuptools

    - name: Add Docker GPG apt Key
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present

    - name: Add Docker Repository
      apt_repository:
        repo: deb https://download.docker.com/linux/ubuntu focal stable
        state: present

    - name: Install Docker
      apt:
        name: docker-ce
        state: present
        update_cache: yes

    - name: Start and enable Docker service
      systemd:
        name: docker
        state: started
        enabled: yes

    - name: Install Docker Compose plugin
      shell: |
        DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
        mkdir -p $DOCKER_CONFIG/cli-plugins
        curl -SL https://github.com/docker/compose/releases/download/v2.23.3/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose
        chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
      args:
        creates: /root/.docker/cli-plugins/docker-compose

    - name: Install Docker SDK for Python
      apt:
        name: python3-docker
        state: present
        update_cache: yes

    - name: Create application directory
      file:
        path: "{{ app_dir }}"
        state: directory
        mode: '0755'

    - name: Create nginx configuration directory
      file:
        path: "{{ app_dir }}/nginx"
        state: directory
        mode: '0755'

    - name: Create letsencrypt directory
      file:
        path: "{{ app_dir }}/certbot"
        state: directory
        mode: '0755'

    - name: Copy nginx configuration
      template:
        src: templates/nginx.conf.j2
        dest: "{{ app_dir }}/nginx/nginx.conf"
        mode: '0644'

    - name: Copy docker-compose file
      template:
        src: templates/docker-compose.prod.yml.j2
        dest: "{{ docker_compose_file }}"
        mode: '0644'

    - name: Stop existing services
      community.docker.docker_compose_v2:
        project_src: "{{ app_dir }}"
        files:
          - "docker-compose.prod.yml"
        state: absent
      ignore_errors: yes

    - name: Copy environment file
      template:
        src: templates/.env.j2
        dest: "{{ env_file }}"
        mode: '0644'

    - name: Log into DockerHub
      docker_login:
        username: "{{ dockerhub_username }}"
        password: "{{ dockerhub_token }}"

    - name: Get list of running containers
      shell: docker ps -q
      register: running_containers
      ignore_errors: yes

    - name: Stop running Docker containers
      shell: docker stop {{ running_containers.stdout }}
      ignore_errors: yes
      when: running_containers.stdout != ""

    - name: Get list of all containers
      shell: docker ps -aq
      register: all_containers
      ignore_errors: yes

    - name: Remove all Docker containers
      shell: docker rm -f {{ all_containers.stdout }}
      ignore_errors: yes
      when: all_containers.stdout != ""

    - name: Find and kill process using port 80 (Windows)
      win_shell: |
        $processIds = @()
        $processIds += Get-NetTCPConnection -LocalPort 80 -ErrorAction SilentlyContinue | Select-Object -ExpandProperty OwningProcess
        foreach ($pid in $processIds) {
            try {
                Stop-Process -Id $pid -Force -ErrorAction SilentlyContinue
                Write-Host "Stopped process with ID: $pid"
            } catch {
                Write-Host "Failed to stop process with ID: $pid"
            }
        }
      ignore_errors: yes

    - name: Pause for processes to stop
      pause:
        seconds: 5

    - name: Ensure Docker network exists
      docker_network:
        name: app-network
        state: present
      ignore_errors: yes

    - name: Create Docker volumes
      docker_volume:
        name: "{{ item }}"
        state: present
      with_items:
        - "mongodb_data"
      ignore_errors: yes

    - name: Start MongoDB first
      community.docker.docker_compose_v2:
        project_src: "{{ app_dir }}"
        files:
          - "docker-compose.prod.yml"
        services:
          - mongodb
        state: present
        build: "never"

    - name: Wait for MongoDB container to be healthy
      shell: >
        docker inspect --format='{{.State.Health.Status}}'
        $(docker-compose -f {{ docker_compose_file }} ps -q mongodb)
      register: mongodb_health
      until: mongodb_health.stdout == "healthy"
      retries: 30
      delay: 10
      ignore_errors: yes

    - name: Start remaining services
      community.docker.docker_compose_v2:
        project_src: "{{ app_dir }}"
        files:
          - "docker-compose.prod.yml"
        services:
          - backend
          - frontend
        state: present
        build: "never"
      register: compose_result

    - name: Wait for backend to be healthy
      shell: >
        docker inspect --format='{{.State.Health.Status}}'
        $(docker-compose -f {{ docker_compose_file }} ps -q backend)
      register: backend_health
      until: backend_health.stdout == "healthy"
      retries: 30
      delay: 10
      ignore_errors: yes

    - name: Check if certificate exists
      stat:
        path: "/etc/letsencrypt/live/{{ domain_name }}/fullchain.pem"
      register: cert_exists

    - name: Get SSL certificate when needed
      block:
        - name: Stop frontend container for certificate acquisition
          community.docker.docker_compose_v2:
            project_src: "{{ app_dir }}"
            files:
              - "docker-compose.prod.yml"
            services: ["frontend"]
            state: absent
          when: not cert_exists.stat.exists

        - name: Wait for port 80 to be free
          wait_for:
            port: 80
            state: stopped
            timeout: 30
          when: not cert_exists.stat.exists

        - name: Get SSL certificate
          command: >
            certbot certonly --standalone
            -d {{ domain_name }}
            --email {{ email }}
            --agree-tos
            --non-interactive
            --preferred-challenges http
          when: not cert_exists.stat.exists

        - name: Wait after certificate acquisition
          wait_for:
            timeout: 10
          when: not cert_exists.stat.exists

        - name: Restart frontend with SSL
          community.docker.docker_compose_v2:
            project_src: "{{ app_dir }}"
            files:
              - "docker-compose.prod.yml"
            services: ["frontend"]
            state: present
          when: not cert_exists.stat.exists
      when: not cert_exists.stat.exists
      ignore_errors: yes

    - name: Create certbot renewal cron job
      cron:
        name: "Certbot Renewal"
        minute: "0"
        hour: "0"
        day: "1"
        job: "docker compose -f {{ docker_compose_file }} down && certbot renew --quiet && docker compose -f {{ docker_compose_file }} up -d"
